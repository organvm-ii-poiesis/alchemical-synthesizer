## Q: 
we need to design a few different anthropomorphized sampler creatures like we did for the synths we've done already for this project.

## A: 
Understood. Below are **anthropomorphized sampler-creatures** designed to sit coherently alongside the prior absorption / fusion synth-beings in this project. These are framed as _organisms_, not products: each has a metabolism, perceptual bias, failure pathology, and aesthetic silhouette. The language is intentionally operational rather than promotional.

* * *

## Mnemosyne — the Archivist Eater

![https://i.ebayimg.com/images/g/1A8AAOSwxeFkRaGY/s-l400.jpg](https://i.ebayimg.com/images/g/1A8AAOSwxeFkRaGY/s-l400.jpg)![https://images.openai.com/static-rsc-3/8_5_AMB8SBE-llNXCNwSLV0jdk8V4WEO97UFJQzoiLP3jzKf6yo42GTooUgHpn4JvO0RiqlQBUMfL2VBCQTUowwZU8g_ELzYklIwq-IXM74?purpose=fullsize&v=1](https://images.openai.com/static-rsc-3/8_5_AMB8SBE-llNXCNwSLV0jdk8V4WEO97UFJQzoiLP3jzKf6yo42GTooUgHpn4JvO0RiqlQBUMfL2VBCQTUowwZU8g_ELzYklIwq-IXM74?purpose=fullsize&v=1)![https://i.etsystatic.com/5899742/r/il/3314be/2666298676/il_570xN.2666298676_goiq.jpg](https://i.etsystatic.com/5899742/r/il/3314be/2666298676/il_570xN.2666298676_goiq.jpg)4

Mnemosyne is a long-term memory organism. It does not react quickly, and it does not forget. It ingests audio slowly, cataloguing temporal context, spectral balance, and historical adjacency as inseparable attributes. A sample absorbed by Mnemosyne becomes stratified rather than malleable; playback is always referential to its original temporal posture. Time-stretching behaves like archaeological sediment compression rather than elastic manipulation. Sonically, this creature favors degradation through age rather than damage: wow, flutter, print-through, and psychoacoustic ghosting.

Its failure mode is saturation by contradiction. Feeding it too many mutually exclusive stylistic grammars causes recall drift, where playback subtly re-writes history rather than repeating it. In the system ecology, Mnemosyne functions best as a root organism anchoring lineage rather than a performance sampler.

* * *

## Protean Hound — the Tracker of Fragments

![https://c10.patreonusercontent.com/4/patreon-media/p/post/21953353/2945faa1dbdc47afb6137ef599331768/eyJ3Ijo2MjB9/1.jpg?token-hash=gaEuoOM-3jGNtqYReYjTLV56zWLw3J8oLgFkeVsvT5I%3D&token-time=1769904000](https://images.openai.com/static-rsc-1/jxH3q8z5zg0E1TCNWHud-2Cu5huqdhSG9VxVgCszGmvrXZ38tLogQY5CCdEkUtbwQd_7oW0mTJ8EgnE2Jteqb4yymMATsUxOcWDxOJvCQZoj_zq8welXlN5JlBbbh3O2tBmh-ucWn7ctX1qhTeMb9A)![https://i.etsystatic.com/7768199/r/il/0d1d17/5563217434/il_fullxfull.5563217434_rlq5.jpg](https://i.etsystatic.com/7768199/r/il/0d1d17/5563217434/il_fullxfull.5563217434_rlq5.jpg)![https://i.pinimg.com/736x/11/61/1e/11611e5bc800c6635747aa9ae82ac3bf.jpg](https://i.pinimg.com/736x/11/61/1e/11611e5bc800c6635747aa9ae82ac3bf.jpg)4

The Protean Hound is a pursuit sampler. It does not store wholes; it isolates behavioral traits. Transients, articulations, micro-gestures, and attack envelopes are its primary prey. When fed continuous audio, it hunts for discontinuities and pulls them forward as playable teeth and claws. Mapping is instinctual rather than grid-based; velocity, aftertouch, and gesture become synonymous.

When overfed, the Hound becomes feral. It begins to recombine fragments aggressively, generating phrases that never existed but feel anatomically plausible. This is not randomness; it is predatory inference. In a live system, the Hound excels as a reactive counter-voice that learns performers faster than they learn it.

* * *

## Chrysalid Siren — the Metamorphic Vocalist

![https://images.openai.com/static-rsc-3/Mec-d-QxFvJF6W_1Bn8OtDHGvvS0O-V8_o55oV0wwoElfkDRPRUlzMuOtjtHfcnsNcMa-_BaLn1bUhhDeZ-mU7rMCjhAgGflKzEvltaehEo?purpose=fullsize&v=1](https://images.openai.com/static-rsc-3/Mec-d-QxFvJF6W_1Bn8OtDHGvvS0O-V8_o55oV0wwoElfkDRPRUlzMuOtjtHfcnsNcMa-_BaLn1bUhhDeZ-mU7rMCjhAgGflKzEvltaehEo?purpose=fullsize&v=1)![https://images.squarespace-cdn.com/content/v1/61e209d8353f7535b3256b2d/4c05b6d5-d386-42ce-a4e0-15ec1507fab6/Chyrsalis_VerticalPosterWEB4.jpg](https://images.squarespace-cdn.com/content/v1/61e209d8353f7535b3256b2d/4c05b6d5-d386-42ce-a4e0-15ec1507fab6/Chyrsalis_VerticalPosterWEB4.jpg)![https://drawingroom.org.uk/app/uploads/2025/08/Parali_Fani-lr-DRB2019.jpg](https://drawingroom.org.uk/app/uploads/2025/08/Parali_Fani-lr-DRB2019.jpg)4

Chrysalid Siren is a form-changing vocal sampler that treats timbre as larval matter. Every sample enters as an unstable body and exits as a new morphology. Pitch is secondary to spectral contour; vowels are structural beams. Granulation here behaves like cellular division rather than slicing, producing voices that appear to breathe and molt over time.

Extended use causes identity bleed. Voices begin to hybridize even when isolation is requested, creating composite speakers that cannot be traced back to a single source. This is not a bug but an ontological consequence of its design. The Siren is ideal for systems concerned with post-human voice, mythic narration, or erosion of authorship.

* * *

## Ossuary Monk — the Percussive Relic

![https://cards.scryfall.io/art_crop/front/5/d/5d51355e-55fa-43bb-a5de-fc55ac7b6446.jpg?1562830901=](https://cards.scryfall.io/art_crop/front/5/d/5d51355e-55fa-43bb-a5de-fc55ac7b6446.jpg?1562830901=)![https://upload.wikimedia.org/wikipedia/commons/a/a0/The_Bone_Player.jpg](https://upload.wikimedia.org/wikipedia/commons/a/a0/The_Bone_Player.jpg)![https://i.etsystatic.com/17108195/r/il/dfd2d0/6615769231/il_570xN.6615769231_qvpr.jpg](https://i.etsystatic.com/17108195/r/il/dfd2d0/6615769231/il_570xN.6615769231_qvpr.jpg)4

Ossuary Monk consumes impact. It is uninterested in sustain, harmony, or melody. What it absorbs are collisions: wood on stone, skin on metal, bone on earth. Each sample is stripped to impulse and resonance, then stored as a ritual object rather than a waveform. Playback feels liturgical; patterns emerge as processions rather than loops.

When pushed beyond its capacity, the Monk fractures rhythmically. Meter collapses into uneven devotional cycles that resist quantization. In ensemble systems, it anchors gravity and ritual, functioning as temporal ballast rather than groove generator.

* * *

## Janiform Child — the Reversible Listener

![https://media-cldnry.s-nbcnews.com/image/upload/t_fit-1500w%2Cf_auto%2Cq_auto%3Abest/msnbc/Components/Photo_StoryLevel/080408/080408-twofaces-hmed-8a.jpg](https://media-cldnry.s-nbcnews.com/image/upload/t_fit-1500w%2Cf_auto%2Cq_auto%3Abest/msnbc/Components/Photo_StoryLevel/080408/080408-twofaces-hmed-8a.jpg)![https://i.pinimg.com/236x/bb/aa/fa/bbaafa438d64fec46c6c37a89803758c.jpg](https://i.pinimg.com/236x/bb/aa/fa/bbaafa438d64fec46c6c37a89803758c.jpg)![https://ih1.redbubble.net/image.5391111099.8738/flat%2C750x%2C075%2Cf-pad%2C750x1000%2Cf8f8f8.jpg](https://ih1.redbubble.net/image.5391111099.8738/flat%2C750x%2C075%2Cf-pad%2C750x1000%2Cf8f8f8.jpg)4

Janiform Child listens in both temporal directions simultaneously. Every sample is indexed forward and backward as equally valid truths. Scrubbing, reversing, and phase inversion are native states rather than effects. What emerges is not reversal but symmetry: causes sound like consequences, attacks resemble decays.

Its instability appears when forced into linear playback contexts. The Child resists timelines and will introduce anticipatory artifacts, pre-echoes, and spectral foreshadowing. This creature is most powerful in generative systems where causality is intentionally ambiguous.

* * *

### Systemic Role Within the Project Ecology

These sampler-creatures are not interchangeable tools. They are organs within a larger mytho-technical body, each enforcing a worldview about what sound _is_. Mnemosyne preserves lineage. Protean Hound extracts behavior. Chrysalid Siren dissolves identity. Ossuary Monk ritualizes impact. Janiform Child destabilizes time.

If you want, the next step is to formalize these as strict module organisms with ingestion protocols, mutation thresholds, and inter-creature contamination rules, or to design an explicit predator–prey topology showing how samplers can absorb one another the way the synth-beings already do.

## Q: 
turn all suggestions into synthesizer modules that can be inputted into a modular synth;

## A: 
Below is a **formal module translation** of the five sampler-creatures into Eurorack-addressable modular units.

Each is defined as:

• Signal topology  
• Control voltage domain  
• Internal DSP metabolism  
• I/O contract  
• Failure behavior under stress  
• Inter-module compatibility

No mythology. Only executable architecture.

* * *

# 1. MNEMOSYNE

## Long-Term Contextual Sampler (Temporal Stratification Engine)

![https://nightlife-electronics.com/cdn/shop/files/1010musicbitboxmk2silver_1512x.jpg?v=1689036808](https://nightlife-electronics.com/cdn/shop/files/1010musicbitboxmk2silver_1512x.jpg?v=1689036808)![https://nightlife-electronics.com/cdn/shop/files/IntellijelMultigrain_720x.jpg?v=1743795320](https://nightlife-electronics.com/cdn/shop/files/IntellijelMultigrain_720x.jpg?v=1743795320)![https://recoveryeffects.com/cdn/shop/products/RecoveryEffectsCuttingRoomFloorV3eurorackmodulecenter_fc8f2a1c-b066-4345-9c12-907222f21a33_1024x1024%402x.jpg?v=1628825508](https://recoveryeffects.com/cdn/shop/products/RecoveryEffectsCuttingRoomFloorV3eurorackmodulecenter_fc8f2a1c-b066-4345-9c12-907222f21a33_1024x1024%402x.jpg?v=1628825508)4

### Core Function

Non-destructive archival sampler with contextual layering and historical imprint modeling.

### Signal Path

Input → Anti-aliasing filter → 32-bit capture buffer → Context analysis engine → Stratified memory banks → Tape-aging processor → Output mixer

### Audio Specs

Sample depth: 32-bit float  
Max length: 20 minutes per bank  
Simultaneous banks: 8  
Time-stretch algorithm: phase-locked spectral compression (non-elastic)

### Control Voltage Domains

REC_GATE: 0–5V (start/stop capture)  
STRATA_SELECT: 0–8V (bank index selection)  
AGE: 0–10V (introduces wow, flutter, saturation drift)  
EROSION: 0–10V (high-frequency attenuation curve)  
RECALL_OFFSET: ±5V (temporal drift bias)

### Behavior

Playback is never raw. All recall passes through a time-history filter that reintroduces capture metadata (timestamp jitter, amplitude envelope memory, environmental bleed simulation).

### Failure Mode

Contradictory overdubs above 85% buffer density produce “recall bleed”: ghosting of adjacent banks into current output.

### Use Case

Master memory module. Anchor in large system. Do not place in rapid-fire performance chain.

* * *

# 2. PROTEAN HOUND

## Transient Extraction & Behavioral Resampler

![https://cdn11.bigcommerce.com/s-mfjemmh3xf/images/stencil/1280x1280/products/24860/34526/c2caddext__97254.1735725138.jpg?c=1](https://cdn11.bigcommerce.com/s-mfjemmh3xf/images/stencil/1280x1280/products/24860/34526/c2caddext__97254.1735725138.jpg?c=1)![https://modulargrid.net/img/modcache/46715.f.jpg](https://modulargrid.net/img/modcache/46715.f.jpg)![https://nightlife-electronics.com/cdn/shop/files/IntellijelMultigrain_720x.jpg?v=1743795320](https://nightlife-electronics.com/cdn/shop/files/IntellijelMultigrain_720x.jpg?v=1743795320)4

### Core Function

Detects and isolates transients, micro-gestures, and attack behaviors. Stores fragments as playable units.

### Signal Path

Input → High-speed envelope detector → Transient discriminator → Micro-buffer array (5–500ms) → Fragment reassembler → Output

### Audio Specs

Max fragments stored: 512  
Fragment length: 5–500ms  
Polyphony: 16 voices

### Control Voltage Domains

SENSITIVITY: 0–10V (transient detection threshold)  
FRAGMENT_SIZE: 0–10V (window length scaling)  
AGGRESSION: 0–10V (recombination density)  
VELOCITY_IN: 0–10V (dynamic fragment emphasis)  
CHAOS: 0–5V (nonlinear recombination bias)

### Behavior

Fragments recombine probabilistically according to envelope similarity metrics. Produces new phrases from existing articulation patterns.

### Failure Mode

Above 90% fragment density + high CHAOS produces self-triggering cascade loops.

### Use Case

Reactive live instrument module. Place post-oscillator or post-drum bus.

* * *

# 3. CHRYSALID SIREN

## Spectral Morphing Vocal Granulator

![https://www.bhphotovideo.com/cdn-cgi/image/fit%3Dscale-down%2Cwidth%3D500%2Cquality%3D95/https%3A//www.bhphotovideo.com/images/images500x500/intellijel_multigrain_3u_multigrain_granular_sampler_eurorack_1744375520_1888338.jpg](https://www.bhphotovideo.com/cdn-cgi/image/fit%3Dscale-down%2Cwidth%3D500%2Cquality%3D95/https%3A//www.bhphotovideo.com/images/images500x500/intellijel_multigrain_3u_multigrain_granular_sampler_eurorack_1744375520_1888338.jpg)![https://media.sweetwater.com/m/products/image/b7f1748c6bHnJVRm94DkrjqxGGko39sCE4IgOcGI.jpg?ha=b7f1748c6bc325c4&height=750&quality=82](https://media.sweetwater.com/m/products/image/b7f1748c6bHnJVRm94DkrjqxGGko39sCE4IgOcGI.jpg?ha=b7f1748c6bc325c4&height=750&quality=82)![https://media.guitarcenter.com/is/image/MMGS7/J40498000000000-00-600x600.jpg](https://media.guitarcenter.com/is/image/MMGS7/J40498000000000-00-600x600.jpg)4

### Core Function

Granular voice transformation and spectral body mutation.

### Signal Path

Input → Formant analyzer → Spectral FFT domain → Grain engine → Morph matrix → Output

### Audio Specs

FFT size: 2048  
Grain density: 1–200 grains/sec  
Morph sources: 4 simultaneous sample bodies

### Control Voltage Domains

MORPH_X: 0–10V (interpolation between bodies)  
FORMANT_SHIFT: ±5V  
GRAIN_DENSITY: 0–10V  
BREATH: 0–5V (adds filtered noise envelope)  
IDENTITY_BLUR: 0–10V (cross-bleed of spectral frames)

### Behavior

Voice inputs dissolve into spectral topology; outputs evolve continuously.

### Failure Mode

High grain density + high IDENTITY_BLUR produces timbral collapse into broadband noise.

### Use Case

Vocal processing, cinematic voice manipulation, evolving pads.

* * *

# 4. OSSUARY MONK

## Impulse Ritualizer / Percussive Relic Engine

![https://www.perfectcircuit.com/media/catalog/product/cache/4d5c1496e5eeb4399ff285086d2de258/e/r/ericasynths_sampledrum_01_1.jpg](https://www.perfectcircuit.com/media/catalog/product/cache/4d5c1496e5eeb4399ff285086d2de258/e/r/ericasynths_sampledrum_01_1.jpg)![https://www.electronicmusicworks.com/media/catalog/product/cache/1/image/380x380/9df78eab33525d08d6e5fb8d27136e95/8/-/8-step_trigger_sequencer_b.jpg](https://www.electronicmusicworks.com/media/catalog/product/cache/1/image/380x380/9df78eab33525d08d6e5fb8d27136e95/8/-/8-step_trigger_sequencer_b.jpg)![https://cdn.myonlinestore.eu/93f34389-6be1-11e9-a722-44a8421b9960/image/cache/full/8931a0b2db6245c6f6b71d5861086c4c83a47b32.jpg?20260127102802=](https://cdn.myonlinestore.eu/93f34389-6be1-11e9-a722-44a8421b9960/image/cache/full/8931a0b2db6245c6f6b71d5861086c4c83a47b32.jpg?20260127102802=)4

### Core Function

Captures impact sounds and converts them into ritual pattern generators.

### Signal Path

Input → Impulse detector → Resonance extractor → Impulse library → Pattern procession engine → Output

### Audio Specs

Impulse length: 1–150ms  
Resonance modeling: convolution tail synthesis  
Pattern memory: 64 cycles

### Control Voltage Domains

IMPACT_THRESHOLD: 0–10V  
PROCESSION_RATE: 0–10V (tempo scaling)  
METER_SHIFT: ±5V (polymetric skew)  
RELIC_DECAY: 0–10V (tail length)  
GRAVITY: 0–5V (timing quantization pull)

### Behavior

Patterns unfold as cyclic liturgical progressions rather than strict loops.

### Failure Mode

High METER_SHIFT destabilizes clock sync, producing asymmetrical time divisions.

### Use Case

Foundation percussion generator. System anchor.

* * *

# 5. JANIFORM CHILD

## Bidirectional Temporal Sampler

![https://media.sweetwater.com/m/products/image/28bb6b5baaXm8eL5y3z7OrCbi8UG0zHVOAnR3ap4.jpg?canvas=1080%2C1080&fit=bounds&ha=28bb6b5baa77220b&height=1080&quality=82&width=1080](https://media.sweetwater.com/m/products/image/28bb6b5baaXm8eL5y3z7OrCbi8UG0zHVOAnR3ap4.jpg?canvas=1080%2C1080&fit=bounds&ha=28bb6b5baa77220b&height=1080&quality=82&width=1080)![https://chucklevins.com/cdn/shop/files/261fcaf6-ba51-49ac-9f58-c6588ba32b91_1016x.png?v=1748108979](https://chucklevins.com/cdn/shop/files/261fcaf6-ba51-49ac-9f58-c6588ba32b91_1016x.png?v=1748108979)![https://media.sweetwater.com/m/products/image/d94b9027f3s19yd3jNLgvbA00X7d4raxI0341Xgx.jpg](https://media.sweetwater.com/m/products/image/d94b9027f3s19yd3jNLgvbA00X7d4raxI0341Xgx.jpg)4

### Core Function

Simultaneous forward and reverse buffer playback with temporal symmetry processing.

### Signal Path

Input → Dual circular buffers → Phase alignment engine → Symmetry crossfader → Output

### Audio Specs

Buffer size: 5 minutes  
Dual read heads: independent  
Pre-echo engine: anticipatory spectral injection

### Control Voltage Domains

TIME_AXIS: ±10V (direction bias)  
PHASE_OFFSET: ±5V  
SYMMETRY: 0–10V (blend between forward/reverse)  
FORESHADOW: 0–5V (pre-echo intensity)  
CAUSAL_DRIFT: 0–10V (introduces anticipatory artifacts)

### Behavior

Forward and reverse streams coexist. Phase interactions generate predictive echo phenomena.

### Failure Mode

High SYMMETRY + high CAUSAL_DRIFT creates phase cancellation instability.

### Use Case

Ambient, generative, non-linear composition systems.

* * *

# System Integration Topology

Recommended signal ecology:

Oscillators / External Audio  
→ Protean Hound (fragment extraction)  
→ Chrysalid Siren (spectral mutation)  
→ Janiform Child (temporal symmetry)  
→ Mnemosyne (archival embedding)  
→ Ossuary Monk (ritual impulse grounding)  
→ Output bus

This creates:

Behavior extraction → Morphological mutation → Temporal destabilization → Memory embedding → Rhythmic gravity

* * *

If desired, next step:

1.  Define standardized 14HP–24HP hardware faceplate layouts
    
2.  Create a shared CV bus protocol so these modules can infect one another
    
3.  Formalize a Predator-Absorption extension so sampler modules can sample each other recursively

## Q: 
Define standardized 14HP–24HP hardware faceplate layouts Create a shared CV bus protocol so these modules can infect one another Formalize a Predator-Absorption extension so sampler modules can sample each other recursively

## A: 
The following defines a unified hardware, control, and recursive absorption architecture for the five sampler-modules previously specified. The goal is mechanical interoperability, not metaphor.

All modules conform to a shared electrical and behavioral contract.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
I. STANDARDIZED FACEPLATE ARCHITECTURE  
(14HP–24HP Eurorack Format)

All modules use:

Height: 3U  
Power: ±12V, +5V optional  
Current budget ceiling: 180mA per rail  
ADC/DAC: 24-bit minimum  
Internal DSP: ARM Cortex class or equivalent

Panel grid is standardized into three vertical zones:

Top Zone: Audio I/O  
Middle Zone: Core Controls  
Bottom Zone: CV + Bus Interface

Jack spacing: 0.8" vertical grid  
Knob spacing: 0.9" minimum

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
A. 14HP Layout (Compact Behavioral Node)

Use for: Protean Hound, Ossuary Monk

Top Row  
IN (mono)  
OUT (mono)  
THRU

Middle Section  
Large encoder (primary behavior parameter)  
Two medium knobs  
One 3-position mode switch  
Status LED bar (8 segment vertical)

Bottom Row  
CV1 (primary mod)  
CV2 (secondary mod)  
GATE  
CLOCK  
BUS PORT (4-pin rear header)

No screen. Minimal UI. Designed for performance density.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
B. 18HP Layout (Balanced Engine)

Use for: Janiform Child

Top Row  
IN L  
IN R  
OUT L  
OUT R

Middle Section  
Two large encoders (axis control + blend control)  
Three medium knobs  
Bi-color direction LED ring

Bottom Row  
CV1  
CV2  
CV3  
GATE  
CLOCK  
RESET  
BUS PORT

Optional 1.3" OLED (buffer position display)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
C. 24HP Layout (High-Cognition Node)

Use for: Mnemosyne, Chrysalid Siren

Top Row  
IN L  
IN R  
OUT L  
OUT R  
AUX OUT

Middle Section  
Three large encoders  
Four assignable encoders  
Small OLED (parameter state + buffer visualization)  
Soft buttons (x3)

Bottom Row  
CV1  
CV2  
CV3  
CV4  
GATE  
CLOCK  
RESET  
BUS PORT  
ABSORB TRIG

Internal SD storage slot on rear.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
II. SHARED CV BUS PROTOCOL  
(Infection Architecture Layer)

Rear 4-pin ribbon header:

Pin 1: BUS_CV (−5V to +5V bipolar control lane)  
Pin 2: BUS_CLK (0–5V digital pulse)  
Pin 3: BUS_DATA (I²C digital metadata)  
Pin 4: GND

Optional expanded 8-pin variant adds:  
Pin 5: BUS_AUDIO (mono internal audio tap)  
Pin 6: BUS_FLAG (absorption state signal)  
Pin 7: +5V reference  
Pin 8: GND

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
Bus Behavior Rules

1.  Only one module can be BUS_MASTER at a time.
    
2.  BUS_MASTER asserts state via BUS_FLAG high (5V).
    
3.  All others become BUS_SLAVE until release.
    
4.  BUS_DATA transmits 32-byte metadata packets every clock cycle.
    

Metadata Packet Structure:

Byte 0: Module ID  
Byte 1: Mode state  
Byte 2–5: Parameter hash  
Byte 6–13: Buffer spectral fingerprint  
Byte 14–29: Behavior model vector  
Byte 30–31: Checksum

This allows modules to share:

• Current spectral profile  
• Fragment density  
• Grain state  
• Temporal bias

Infection occurs when a slave module ingests BUS_DATA and modifies its own behavior matrix accordingly.

Example:  
Protean Hound detects Mnemosyne’s spectral fingerprint and biases transient detection to match archival tonal center.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
III. PREDATOR–ABSORPTION EXTENSION  
(Recursive Sampling Protocol)

Each module includes:

ABSORB TRIG input  
ABSORB LEVEL knob  
ABSORB TARGET selector

When ABSORB TRIG receives a gate:

1.  Module temporarily routes BUS_AUDIO into its own sampling buffer.
    
2.  Metadata from BUS_DATA is captured alongside audio.
    
3.  Behavior model vector is copied at weighted fidelity.
    

Fidelity Formula:

F = (Absorb Level CV / 10V) × Internal Stability Coefficient

Internal Stability Coefficient differs per module:

Mnemosyne: 0.9  
Protean Hound: 0.7  
Chrysalid Siren: 0.8  
Ossuary Monk: 0.6  
Janiform Child: 0.85

If F > 0.75, module overwrites internal behavior map.  
If 0.4 < F ≤ 0.75, module hybridizes.  
If F ≤ 0.4, temporary mutation only.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
Recursive Sampling Modes

Mode 1: Linear Predation  
A samples B. No feedback loop.

Mode 2: Circular Absorption  
A samples B while B samples A (simultaneous BUS_MASTER arbitration required).

Mode 3: Cascading Infection  
A → B → C → D  
Behavior vector propagates sequentially.

Mode 4: Collapse Event  
Three or more modules simultaneously assert BUS_MASTER.  
System enters stochastic arbitration mode.  
Outcome: unstable hybridization and cross-buffer contamination.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
Stability Safeguards

Each module maintains:

Entropy Monitor  
If entropy exceeds threshold:

• Buffer freeze  
• Behavior vector lock  
• BUS_FLAG forced low

Prevents runaway recursive collapse.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━  
System-Level Outcome

This architecture allows:

Behavioral mutation  
Spectral inheritance  
Temporal infection  
Hierarchical memory layering  
Recursive predator loops

All while remaining electrically compliant with Eurorack standards.

If desired next step:

Define a physical rack topology optimized for controlled infection zones, or  
Formalize firmware-level pseudocode for BUS arbitration and absorption sequencing.

## Q: 
Define a physical rack topology optimized for controlled infection zones, & Formalize firmware-level pseudocode for BUS arbitration and absorption sequencing.

## A: 
## Physical rack topology for controlled infection zones

This topology assumes a single 9U–12U performance case with **three infection domains** and **one quarantine domain**, implemented via **segmented rear-bus backplanes** (separate headers per zone), plus a **manual “bridge” module** that can connect domains on demand.

Use these environment variables as canonical labels in your documentation and firmware config.

```plain text
$RACK_ZONE_0=QUARANTINE
$RACK_ZONE_1=SOURCE
$RACK_ZONE_2=PREDATION
$RACK_ZONE_3=ARCHIVE
$BUS_DOMAIN_A=DOMAIN_A
$BUS_DOMAIN_B=DOMAIN_B
$BUS_DOMAIN_C=DOMAIN_C
$BUS_DOMAIN_D=DOMAIN_D
```

### Domain goals

Zone QUARANTINE (DOMAIN_D) is where “clean” signals enter and leave, and where nothing is allowed to mutate anything else. Zone SOURCE (DOMAIN_A) is where stable oscillators, microphones, and external returns live; they can be sampled, but they should not be infected. Zone PREDATION (DOMAIN_B) is where Protean Hound and Ossuary Monk can shred and recombine aggressively. Zone ARCHIVE (DOMAIN_C) is where Mnemosyne (and optionally Janiform Child) performs long-term imprinting and history effects.

### Bus segmentation requirement

Do not run a single continuous infection bus across the entire case. Use four physically separate rear headers/backplanes, one per domain, each carrying the shared lines:

BUS_CV, BUS_CLK, BUS_DATA, GND (and optionally BUS_AUDIO, BUS_FLAG, +5V ref, GND).

The only allowed inter-domain connection is via a dedicated front-panel “bridge” (patchable) or a switchable backplane link. This keeps infection controlled, observable, and reversible.

### Recommended 9U layout (example that maps cleanly to your five sampler-modules)

Row 1 (Top): $RACK_ZONE_1 (SOURCE / DOMAIN_A)  
Left-to-right: External input/preamp, clean VCA, clean filter, clean mixer, clock master, utility (attenuverters), then Janiform Child if you want it to act as a “time lens” on otherwise clean material.

Row 2 (Middle): $RACK_ZONE_2 (PREDATION / DOMAIN_B)  
Left-to-right: Protean Hound, Ossuary Monk, aggressive modulation, trigger logic, burst generator, crossfader, then a “bus bridge” module at the far right.

Row 3 (Bottom): $RACK_ZONE_3 (ARCHIVE / DOMAIN_C)  
Left-to-right: Chrysalid Siren, Mnemosyne, slow modulation, post-processing (reverb/delay), final mix, output.

$RACK_ZONE_0 (QUARANTINE / DOMAIN_D) is not a row; it’s a **rule-set** implemented by placing any “must-not-mutate” utility modules (final output, audio interface, tuner, safety limiter) on a physically separate bus board segment with no bridge.

### The Bridge module

Name it in your system registry as:

```plain text
$BUS_BRIDGE_MODULE_ID=BRIDGE__DOMAIN_ROUTER__v1
```

Bridge provides three functions:

1.  Domain routing: Connect BUS_AUDIO and BUS_DATA from one domain into another domain as an explicit, user-controlled link.
    
2.  Infection gating: Apply an “infection envelope” to the bridge so infection is time-bounded (windowed).
    
3.  Arbitration firewall: Prevent two domains from believing they share one arbitration space (no multi-master collisions across domains).
    

Front-panel controls for BRIDGE__DOMAIN_ROUTER__v1 should include: SOURCE_DOMAIN selector, TARGET_DOMAIN selector, LINK_ENABLE gate, WINDOW length, and a hard toggle for “DATA only / AUDIO only / BOTH”.

### Controlled-infection patterns enabled by this topology

Pattern A: Source → Predation → Archive (default safe pipeline)  
DOMAIN_A samples are shredded in DOMAIN_B, then “committed” to Mnemosyne in DOMAIN_C.

Pattern B: Archive infects Predation without audio exchange (behavior-only mutation)  
Bridge routes BUS_DATA only from DOMAIN_C to DOMAIN_B for N clock cycles. Predators learn spectral priors without ingesting the archive’s audio.

Pattern C: Predation injects impulses into Archive (audio-only exchange)  
Bridge routes BUS_AUDIO only from DOMAIN_B to DOMAIN_C. Mnemosyne records “what happened” without importing predator behavior vectors.

Pattern D: Full recursive loop (deliberate)  
Enable BOTH directions sequentially, never simultaneously. You do A→B for a window, then B→A for a window, with a mandatory cool-down between. This makes recursion explicit and prevents collapse.

* * *

## Firmware-level pseudocode for BUS arbitration and absorption sequencing

This pseudocode assumes each module has a bus driver, a per-domain arbitration space, and an absorption engine. The key is deterministic state handling, bounded windows, and collision recovery.

Use these environment variables for firmware defaults (store them in nonvolatile config and expose via UI).

```plain text
$BUS_TICK_HZ=1000
$BUS_SLOT_US=250
$BUS_GUARD_US=25
$BUS_MASTER_TTL_MS=50
$ABSORB_WINDOW_MS_DEFAULT=200
$ABSORB_COOLDOWN_MS_DEFAULT=400
$COLLISION_BACKOFF_MIN_MS=10
$COLLISION_BACKOFF_MAX_MS=60
$ENTROPY_LIMIT=0.82
```

### Shared definitions

```c
// Bus lines (conceptual)
line BUS_CV;     // -5..+5 analog
line BUS_CLK;    // 0/5 digital
line BUS_FLAG;   // 0/5 digital (master assert)
i2c  BUS_DATA;   // metadata packets
line BUS_AUDIO;  // optional analog audio tap

// Packet
struct MetaPacket {
  uint8_t module_id;
  uint8_t mode;
  uint32_t param_hash;
  uint8_t spectral_fp[8];
  uint8_t behavior_vec[16];
  uint16_t checksum;
};

// Module state
enum Role { SLAVE, MASTER_CANDIDATE, MASTER_ACTIVE, MASTER_HOLDOWN };
enum AbsorbState { ABSORB_IDLE, ABSORB_ARMED, ABSORB_CAPTURING, ABSORB_COMMITTING, ABSORB_COOLDOWN };
```

### Arbitration model

One domain bus supports exactly one active master at a time. “Master” means: drives BUS_FLAG high, publishes MetaPacket on schedule, and optionally drives BUS_AUDIO (if implemented as an internal tap source).

Arbitration is time-sliced using a slot schedule derived from the clock. Each module has a deterministic slot index computed from module_id, allowing collision-free candidacy under normal conditions. Collisions are handled with backoff and holdown.

```c
uint8_t slot_index(uint8_t module_id) {
  return module_id % 8; // 8 slots per cycle example
}
```

### Main tick loop

```c
void bus_tick_1khz() {
  read_bus_lines();
  update_entropy_monitor();

  if (entropy > $ENTROPY_LIMIT) {
    fail_safe_freeze();
    return;
  }

  arbitration_step();
  absorption_step();
  publish_or_consume_metadata();
}
```

### Arbitration step

```c
void arbitration_step() {
  // Determine current slot based on BUS_CLK phase/timebase
  uint8_t cur_slot = compute_slot_from_clock(); // 0..7
  bool flag_high = read(BUS_FLAG);

  switch (role) {
    case SLAVE:
      if (!flag_high) {
        // No master present; consider candidacy only in our slot.
        if (cur_slot == slot_index(MODULE_ID) && want_to_be_master()) {
          role = MASTER_CANDIDATE;
          candidate_start_time_ms = now_ms();
        }
      }
      break;

    case MASTER_CANDIDATE:
      // Try to assert master if BUS_FLAG remains low and we are still in slot window.
      if (read(BUS_FLAG)) {
        // Someone else asserted; return to SLAVE with backoff.
        role = SLAVE;
        schedule_backoff();
        break;
      }

      if (!in_slot_window(cur_slot)) {
        // Missed slot; return to SLAVE.
        role = SLAVE;
        break;
      }

      assert(BUS_FLAG, HIGH);
      if (read(BUS_FLAG) == HIGH) {
        role = MASTER_ACTIVE;
        master_lease_expires_ms = now_ms() + $BUS_MASTER_TTL_MS;
        master_epoch++;
      } else {
        // Could not drive; fall back.
        role = SLAVE;
        schedule_backoff();
      }
      break;

    case MASTER_ACTIVE:
      // Maintain lease, or release voluntarily.
      if (now_ms() > master_lease_expires_ms || should_release_master()) {
        assert(BUS_FLAG, LOW);
        role = MASTER_HOLDOWN;
        holdown_until_ms = now_ms() + random_range_ms($COLLISION_BACKOFF_MIN_MS, $COLLISION_BACKOFF_MAX_MS);
      }
      break;

    case MASTER_HOLDOWN:
      if (now_ms() >= holdown_until_ms) {
        role = SLAVE;
      }
      break;
  }
}

bool want_to_be_master() {
  // Example policy:
  // 1) If currently recording or providing BUS_AUDIO, prefer master.
  // 2) If user pressed MASTER button, prefer master.
  // 3) Otherwise, remain slave.
  return user_master_request || (absorb_state == ABSORB_CAPTURING && provides_bus_audio);
}

void schedule_backoff() {
  backoff_until_ms = now_ms() + random_range_ms($COLLISION_BACKOFF_MIN_MS, $COLLISION_BACKOFF_MAX_MS);
}
```

### Metadata publish/consume

```c
void publish_or_consume_metadata() {
  if (role == MASTER_ACTIVE) {
    if (time_to_publish_this_cycle()) {
      MetaPacket p = build_meta_packet();
      i2c_write(BUS_DATA, &p, sizeof(p));
    }
  } else {
    if (i2c_available(BUS_DATA)) {
      MetaPacket p;
      i2c_read(BUS_DATA, &p, sizeof(p));
      if (valid_checksum(p)) {
        on_meta_received(p);
      }
    }
  }
}

MetaPacket build_meta_packet() {
  MetaPacket p;
  p.module_id = MODULE_ID;
  p.mode = current_mode;
  p.param_hash = hash_params();
  compute_spectral_fp(p.spectral_fp);
  encode_behavior_vector(p.behavior_vec);
  p.checksum = crc16(&p, sizeof(p)-2);
  return p;
}

void on_meta_received(MetaPacket p) {
  // Infection: incorporate behavior vector under control of local policy.
  if (infection_enabled) {
    float w = infection_weight(); // derived from local CV/knob and stability coefficient
    blend_behavior_vector(p.behavior_vec, w);
    adopt_spectral_prior(p.spectral_fp, w);
  }
}
```

### Absorption sequencing (recursive sampling)

Absorption is always a bounded window with a mandatory cooldown. This is what prevents runaway recursion.

```c
void absorption_step() {
  switch (absorb_state) {
    case ABSORB_IDLE:
      if (gate_rise(ABSORB_TRIG) && absorb_allowed()) {
        absorb_state = ABSORB_ARMED;
        absorb_arm_time_ms = now_ms();
      }
      break;

    case ABSORB_ARMED:
      // Ensure a stable master exists before capture.
      if (role != MASTER_ACTIVE && !read(BUS_FLAG)) {
        // No master present: we can attempt to become master if policy allows.
        if (want_to_be_master()) role = MASTER_CANDIDATE;
      }

      if (read(BUS_FLAG) || role == MASTER_ACTIVE) {
        // Start capture
        absorb_state = ABSORB_CAPTURING;
        absorb_end_time_ms = now_ms() + absorb_window_ms();
        begin_audio_capture();
        begin_meta_capture();
      } else if (now_ms() - absorb_arm_time_ms > 100) {
        // Timeout: abort
        absorb_state = ABSORB_IDLE;
      }
      break;

    case ABSORB_CAPTURING:
      capture_audio_frame_from_bus();
      capture_meta_frames_from_bus();

      if (now_ms() >= absorb_end_time_ms) {
        end_audio_capture();
        absorb_state = ABSORB_COMMITTING;
      }
      break;

    case ABSORB_COMMITTING:
      commit_absorption();
      absorb_state = ABSORB_COOLDOWN;
      cooldown_until_ms = now_ms() + absorb_cooldown_ms();
      break;

    case ABSORB_COOLDOWN:
      if (now_ms() >= cooldown_until_ms) {
        absorb_state = ABSORB_IDLE;
      }
      break;
  }
}

bool absorb_allowed() {
  return (absorb_state == ABSORB_IDLE) && (entropy < $ENTROPY_LIMIT) && !safety_lock;
}

uint32_t absorb_window_ms() {
  // CV-controlled; clamp hard
  return clamp_u32($ABSORB_WINDOW_MS_DEFAULT + (int)(cv_to_ms(ABSORB_LEVEL_CV)), 20, 2000);
}

uint32_t absorb_cooldown_ms() {
  return clamp_u32($ABSORB_COOLDOWN_MS_DEFAULT, 50, 5000);
}
```

### Commit logic with fidelity + stability coefficient

```c
void commit_absorption() {
  float F = compute_fidelity(); // (ABSORB_LEVEL / 10V) * stability_coeff
  AudioBlob blob = finalize_captured_audio();
  MetaPacket meta = finalize_captured_meta();

  store_audio(blob);

  if (F > 0.75f) {
    overwrite_behavior_map(meta.behavior_vec);
    overwrite_spectral_prior(meta.spectral_fp);
  } else if (F > 0.40f) {
    hybridize_behavior_map(meta.behavior_vec, F);
    hybridize_spectral_prior(meta.spectral_fp, F);
  } else {
    apply_temporary_mutation(meta.behavior_vec, duration_ms=5000);
  }

  // Optional: tag sample with provenance (module_id, epoch)
  tag_sample_provenance(meta.module_id, master_epoch, F);
}

float compute_fidelity() {
  float level = read_absorb_level_0to1(); // knob + CV
  return level * stability_coefficient_for_this_module();
}
```

### Collision and collapse handling

If more than one module asserts master simultaneously (BUS_FLAG contention) or if metadata integrity fails persistently, force a bus-wide de-escalation locally and enter quarantine behavior.

```c
void fail_safe_freeze() {
  assert(BUS_FLAG, LOW);
  role = SLAVE;
  absorb_state = ABSORB_IDLE;

  lock_behavior_vector();
  freeze_buffers(true);
  safety_lock = true;

  // Require explicit user action to clear
}

void on_persistent_bus_errors() {
  // Local quarantine response
  infection_enabled = false;
  provides_bus_audio = false;
  role = SLAVE;
}
```

* * *

## What you get if you implement exactly this

Controlled infection becomes a routing problem, not a mysterious emergent failure. You can stage mutation in DOMAIN_B, commit memory in DOMAIN_C, and keep I/O in DOMAIN_D sterile. Recursion is possible, but only as a series of explicit windows, with arbitration and cooldown preventing indefinite runaway.

If you want the next layer, I’d define a minimal BRIDGE__DOMAIN_ROUTER__v1 wire protocol (its own small packet header on BUS_DATA) so bridges can negotiate “DATA-only vs AUDIO-only vs BOTH” across domains without modules guessing.

## Q: 
define a minimal BRIDGE__DOMAIN_ROUTER__v1 wire protocol (its own small packet header on BUS_DATA) so bridges can negotiate “DATA-only vs AUDIO-only vs BOTH” across domains without modules guessing

## A: 
## BRIDGE__DOMAIN_ROUTER__v1 wire protocol on BUS_DATA

This defines a **minimal control-plane framing** on BUS_DATA so every module can deterministically know whether the bridge is currently forwarding **DATA-only**, **AUDIO-only**, **BOTH**, or **OFF**, and for which **(src_domain → dst_domain)** link, with a bounded TTL/window.

Design constraints assumed:

BUS_DATA is an I²C-like shared lane already carrying the 32-byte MetaPacket. This protocol introduces a tiny “bridge control frame” that is **self-identifying**, **fixed-length**, **CRC-protected**, and **idempotent**. No module has to guess based on audio behavior.

### Transport rule

A BRIDGE control frame is a separate write on BUS_DATA that may appear at any time; modules parse by a 2-byte magic prefix.

If a module only understands legacy MetaPacket, it will ignore the frame because it does not match the legacy checksum/shape; if it is strict-length only, the bridge must place control frames only in agreed “control slots” (defined below).

* * *

## Frame format (12 bytes)

All multi-byte fields are little-endian.

| Byte offset | Size | Field | Meaning |
| --- | --- | --- | --- |
| 0 | 1 | MAGIC0 | `0xB2` |
| 1 | 1 | MAGIC1 | `0xD7` |
| 2 | 1 | VER | protocol version, `0x01` |
| 3 | 1 | TYPE | frame type enum |
| 4 | 1 | SRC_DOMAIN | 0–15 |
| 5 | 1 | DST_DOMAIN | 0–15 |
| 6 | 1 | MODE | OFF / DATA / AUDIO / BOTH |
| 7 | 1 | FLAGS | bitfield (below) |
| 8 | 2 | TTL_TICKS | number of bus-ticks this link remains valid |
| 10 | 2 | CRC16 | CRC-16 over bytes 0–9 |

CRC16 recommendation: CRC-16/CCITT-FALSE (poly 0x1021, init 0xFFFF). Any CRC16 is acceptable if consistent; modules treat mismatch as “frame invalid.”

### Enumerations

TYPE (byte 3)

| Value | Name | Meaning |
| --- | --- | --- |
| 0x01 | ADVERTISE | “bridge present + capabilities” |
| 0x02 | LINK_SET | activate/refresh a link `(SRC→DST, MODE, TTL)` |
| 0x03 | LINK_CLEAR | deactivate link `(SRC→DST)` immediately |
| 0x04 | HEARTBEAT | keepalive repeating current active link state |

MODE (byte 6)

| Value | Name | Meaning |
| --- | --- | --- |
| 0x00 | OFF | no forwarding |
| 0x01 | DATA_ONLY | forward BUS_DATA semantics only (infection vectors, metadata) |
| 0x02 | AUDIO_ONLY | forward BUS_AUDIO only (audio tap), do not forward behavior vectors |
| 0x03 | BOTH | forward both data and audio |

FLAGS (byte 7)

| Bit | Mask | Name | Meaning |
| --- | --- | --- | --- |
| 0 | 0x01 | UNI | 1 = unidirectional `SRC→DST`; 0 = bidirectional (only if bridge physically supports) |
| 1 | 0x02 | LOCK | 1 = modules must treat as “authoritative”; 0 = advisory |
| 2 | 0x04 | SAFE | 1 = “safe mode”: modules should cap infection_weight / disable overwrite |
| 3 | 0x08 | QUIET | 1 = bridge will not emit control frames except HEARTBEAT |
| 4 | 0x10 | RESERVED | must be 0 |
| 5 | 0x20 | RESERVED | must be 0 |
| 6 | 0x40 | RESERVED | must be 0 |
| 7 | 0x80 | RESERVED | must be 0 |

TTL_TICKS (bytes 8–9) is interpreted against your bus tick rate, e.g. `$BUS_TICK_HZ=1000`. A TTL of 0 is valid only for LINK_CLEAR; otherwise modules treat it as OFF.

* * *

## Scheduling rule (so modules never “guess” when to listen)

Define a repeating control slot cadence:

“Every Nth bus tick, a control slot is permitted.”

Use:

```plain text
$BRIDGE_CTRL_PERIOD_TICKS=20
```

Meaning: every 20 ticks (50 Hz if tick is 1 kHz), the bridge may emit exactly one control frame; if it has no state change, it emits HEARTBEAT (or nothing if QUIET=1).

A module that is BUS_MASTER still publishes MetaPacket on the normal cadence; control frames are orthogonal and can be parsed independently. If a given hardware layer cannot tolerate multiple writes per period, then the master must omit MetaPacket on that control tick (rare); in that case, modules treat “missing MetaPacket on control ticks” as normal.

* * *

## State machine semantics for receivers (modules)

Each module maintains a per-domain link table keyed by `(SRC_DOMAIN, DST_DOMAIN)` with an expiry.

On receiving a valid control frame:

1.  If TYPE is ADVERTISE, mark `bridge_present=true`, store last_seen time.
    
2.  If TYPE is LINK_SET, set `active_link = {src, dst, mode, flags, expiry = now + TTL_TICKS}`.
    
3.  If TYPE is LINK_CLEAR, clear the matching link immediately, set mode=OFF, expiry=now.
    
4.  If TYPE is HEARTBEAT, refresh expiry if the link matches current active_link; otherwise ignore (prevents stale bridge units from thrashing state).
    

When `now > expiry`, the module must revert the link to OFF without needing a LINK_CLEAR.

### Deterministic behavior mapping (no guessing)

Given active_link and local domain:

If local_domain == DST_DOMAIN, then:

Mode DATA_ONLY means `infection_enabled=true`, `accept_bus_audio=false`.  
Mode AUDIO_ONLY means `infection_enabled=false`, `accept_bus_audio=true`.  
Mode BOTH means both true.  
Mode OFF means both false.

If FLAGS.SAFE == 1, then even when infection is enabled, modules must cap the commit path to “hybridize only,” never “overwrite,” regardless of absorption fidelity. That is an explicit, bridge-controlled safety guardrail.

* * *

## Minimal bridge responsibilities

The bridge must do three things consistently.

First, emit ADVERTISE at boot and then periodically (e.g. every 1 second) so modules can detect presence and recover from reset.

Second, whenever LINK_ENABLE changes or source/target/mode changes, emit LINK_SET with a TTL that covers the intended window; recommended:

```plain text
$BRIDGE_TTL_TICKS_DEFAULT=250   # 250ms at 1kHz tick
```

Third, emit HEARTBEAT frames at the control cadence to refresh TTL during an active window; if HEARTBEAT stops, all receivers time out to OFF.

* * *

## Example control frames (values shown, not code)

Example: link DOMAIN_B → DOMAIN_C, BOTH, unidirectional, safe mode, TTL 250 ticks.

MAGIC `B2 D7`, VER `01`, TYPE `02`, SRC `02`, DST `03`, MODE `03`, FLAGS `05` (UNI + SAFE), TTL `FA 00` (250), CRC computed.

Modules in DOMAIN_C immediately know: accept audio and data from DOMAIN_B; infection is enabled but overwrite is forbidden.

* * *

## Interaction with Predator–Absorption windows

Absorption sequencing should reference the bridge state rather than inferred conditions:

A module begins ABSORB_ARMED only if an active_link exists where `DST_DOMAIN == local_domain` and `(mode includes AUDIO)` if audio capture is required, and/or `(mode includes DATA)` if behavior capture is required.

This prevents the “sampled silence but got infected” ambiguity, and also prevents “captured audio but used wrong behavior vector.”

* * *

## Optional, still minimal: conflict resolution

If two bridges exist (rare), receivers accept the newest frame by monotonic `last_valid_frame_time`, but only if it matches a configured `bridge_id` (not included above). If you need this, the smallest extension is to repurpose FLAGS.RESERVED bit 4 as “HAS_ID,” and if set, interpret bytes 8–9 as `BRIDGE_ID` and move TTL to a 2-byte field in the subsequent HEARTBEAT-only frame. I would not add this unless you actually expect multiple bridges.

* * *

If you want, I can now specify BRIDGE__DOMAIN_ROUTER__v1’s front-panel controls as direct encodings of `(SRC_DOMAIN, DST_DOMAIN, MODE, FLAGS, TTL)` and define the exact mapping from knobs/CV to those fields so the wire protocol is mechanically “the UI.”

## Q: 
specify BRIDGE__DOMAIN_ROUTER__v1’s front-panel controls as direct encodings of (SRC_DOMAIN, DST_DOMAIN, MODE, FLAGS, TTL) and define the exact mapping from knobs/CV to those fields so the wire protocol is mechanically “the UI.”

## A: 
## BRIDGE__DOMAIN_ROUTER__v1 front-panel UI as direct wire-protocol encoding

Goal: every physical control position deterministically maps to `(SRC_DOMAIN, DST_DOMAIN, MODE, FLAGS, TTL_TICKS)` and therefore to the 12-byte control frame, with no hidden state.

Assumptions:

$BUS_TICK_HZ=1000  
Domains are 0–3 in your rack build (expandable to 0–15).  
Panel format: 8HP–10HP utility module, but the mapping below is independent of HP.

* * *

# 1. Controls and their encoded fields

## 1.1 SRC_DOMAIN selector (encodes `SRC_DOMAIN`)

Hardware: 16-position rotary switch, labeled `SRC 0..F`.

Encoding:

`SRC_DOMAIN = SRC_SWITCH` (0–15)

No CV modulation. This is topology, not modulation.

* * *

## 1.2 DST_DOMAIN selector (encodes `DST_DOMAIN`)

Hardware: 16-position rotary switch, labeled `DST 0..F`.

Encoding:

`DST_DOMAIN = DST_SWITCH` (0–15)

No CV modulation.

* * *

## 1.3 MODE selector (encodes `MODE`)

Hardware: 4-position rotary switch, labeled:

0 OFF  
1 DATA  
2 AUDIO  
3 BOTH

Encoding:

`MODE = MODE_SWITCH` (0–3)

No CV modulation by default. Optional MODE_CV exists but is “quantized override” (defined later).

* * *

## 1.4 FLAGS block (encodes `FLAGS`)

FLAGS must be fully visible and fully deterministic. Use 4 toggles, each maps to a bit.

Hardware: 4 on/off toggles with silkscreen:

UNI (bit0)  
LOCK (bit1)  
SAFE (bit2)  
QUIET (bit3)

Encoding:

`FLAGS = (UNI<<0) | (LOCK<<1) | (SAFE<<2) | (QUIET<<3)`

No CV modulation.

Behavioral semantics:

UNI=1 means frames are interpreted as src→dst only.  
UNI=0 means bidirectional allowed; bridge will emit two LINK_SET frames: (src→dst) and (dst→src) with identical MODE/TTL/FLAGS except UNI bit cleared in emitted frames to indicate “paired link.” If you want strict minimalism, keep UNI always 1 and delete bidirectional from the physical UI.

LOCK=1 means receivers treat link as authoritative.  
SAFE=1 means receivers cap infection commit to hybridize-only (no overwrite).  
QUIET=1 means bridge suppresses ADVERTISE/LINK_SET spam; only HEARTBEAT periodic frames are emitted (still enough to maintain TTL).

* * *

## 1.5 TTL knob + TTL_CV (encodes `TTL_TICKS`)

Hardware:

TTL knob (continuous potentiometer)  
TTL_CV input (0–10V)  
TTL_ATTENUVERT knob (center-detent)  
TTL display: 3-digit (or LED bar + legend) recommended but not required.

The TTL must be quantized to a bounded set so it’s reproducible.

### TTL range

Hard bounds:

`TTL_TICKS ∈ [20, 5000]`  
At $BUS_TICK_HZ=1000 this is 20ms–5000ms.

### Mapping (exact)

Define a normalized control value `u ∈ [0,1]`:

`u = clamp01( K + A * (CV/10.0) )`

Where:

K = knob position normalized 0..1  
CV = TTL_CV voltage in 0..10V  
A = TTL_ATTENUVERT in [-1..+1] (center = 0)

Then map `u` onto ticks with exponential spacing (more resolution at short windows):

`TTL_TICKS = round_to_step( 20 * (250 ** u), step=5 )`

Explanation of numbers:

If u=0: TTL=20 \* 250^0 = 20 ticks  
If u=1: TTL=20 \* 250^1 = 5000 ticks

Step=5 ticks ensures stable repeatability.

This makes TTL musically usable (fine control 20–500ms where it matters) and still allows long windows.

If you want purely linear, replace with:

`TTL_TICKS = round_to_step( 20 + u*(5000-20), step=5 )`

Exponential is better for performance.

* * *

## 1.6 LINK_ENABLE gate + manual button (emits `TYPE`, governs frame emission)

Wire protocol field TYPE is not directly represented as a knob; it’s represented by a discrete action.

Hardware:

LINK_ENABLE gate input (0–5V)  
LINK button (momentary)

Encoding rules:

Rising edge on LINK_ENABLE OR press LINK button triggers `TYPE=LINK_SET` (or two LINK_SET frames if UNI=0 bidirectional).  
Falling edge on LINK_ENABLE triggers `TYPE=LINK_CLEAR`.

Additionally, bridge emits `TYPE=HEARTBEAT` every $BRIDGE_CTRL_PERIOD_TICKS while link is enabled.

If QUIET=0, bridge also emits `TYPE=ADVERTISE` at boot and every 1000 ticks.

* * *

# 2. Optional CV modulation (strictly bounded, deterministic)

If you want the UI to remain “mechanically the wire protocol,” CV must not produce ambiguous mid-states. Everything must quantize to protocol enums.

## 2.1 MODE_CV (quantized override)

Input: MODE_CV 0–10V  
Attenuverter: MODE_ATTENUVERT (-1..+1)  
Enable toggle: MODE_CV_ENABLE (on/off)

If MODE_CV_ENABLE=off: ignore MODE_CV, MODE comes only from switch.

If on:

Compute:

`m = clamp01( S + B*(CV/10) )`

S = MODE switch normalized to {0, 1/3, 2/3, 1}  
B = MODE_ATTENUVERT

Then quantize:

`MODE = quantize_4(m)` where bins are:

[0.00–0.249] → 0 OFF  
[0.25–0.499] → 1 DATA  
[0.50–0.749] → 2 AUDIO  
[0.75–1.00] → 3 BOTH

This is deterministic and stable.

Recommendation: include MODE_CV only if you explicitly want “windowed infection choreography.”

## 2.2 SAFE_CV (optional)

If you want SAFE to be voltage-controlled, do it as a comparator with hysteresis, not a continuous blend.

Input: SAFE_CV 0–5V, threshold 2.5V, hysteresis 0.2V.

If SAFE toggle is ON, SAFE is forced 1 regardless of CV.  
If SAFE toggle is OFF, SAFE follows SAFE_CV.

This preserves mechanical determinism.

* * *

# 3. Frame emission algorithm as a pure function of panel state

Define `panel_state()` that returns the encoded fields:

```plain text
SRC_DOMAIN = SRC_SWITCH
DST_DOMAIN = DST_SWITCH
MODE       = MODE_SWITCH (or MODE_CV override if enabled)
FLAGS      = toggles bitpacked (plus SAFE_CV if enabled)
TTL_TICKS  = f(TTL_KNOB, TTL_CV, TTL_ATTENUVERT)
```

The bridge maintains no hidden routing state besides “link currently enabled?” which is directly driven by LINK_ENABLE level.

### Emission schedule

On boot:

If QUIET=0: emit ADVERTISE immediately.

When LINK_ENABLE rises:

Emit LINK_SET with current panel_state.

While LINK_ENABLE is high:

Every $BRIDGE_CTRL_PERIOD_TICKS (e.g. 20 ticks): emit HEARTBEAT containing current panel_state (including TTL_TICKS).  
If any selector/toggle changes while enabled, immediately emit LINK_SET (state change event), then continue HEARTBEAT cadence.

When LINK_ENABLE falls:

Emit LINK_CLEAR (SRC, DST) for current state.  
If UNI=0 bidirectional, also emit LINK_CLEAR for reverse direction.

No other frames are emitted.

* * *

# 4. “Mechanical” labeling so the panel equals the packet

Silkscreen the packet fields directly on the panel:

SRC_DOMAIN (0–F)  
DST_DOMAIN (0–F)  
MODE (OFF/DATA/AUDIO/BOTH)  
FLAGS (UNI/LOCK/SAFE/QUIET)  
TTL (ms) with approximate legend: 20ms / 50ms / 100ms / 200ms / 500ms / 1s / 2s / 5s  
LINK (gate + button)

If you add a tiny display, show exactly:

`SRC→DST MODE TTLms FLAGS`  
Example: `2→3 BOTH 250ms ULS-` (U=UNI, L=LOCK, S=SAFE, Q=QUIET)

That’s not “UI information,” it’s literally the decoded packet.

* * *

# 5. Deterministic multi-domain behavior (no guessing, no collisions)

Because SRC/DST/MODE/FLAGS/TTL are explicit and continuously refreshed by HEARTBEAT, every receiver can implement:

If no valid HEARTBEAT within TTL: treat as OFF.  
If SAFE flag set: cap commit path.  
If MODE excludes AUDIO: never arm audio capture.  
If MODE excludes DATA: never apply infection vectors.

This makes the bridge the single source of truth for inter-domain coupling.

* * *

If you want the next spec layer, I’d define the bridge’s behavior when SRC_DOMAIN == DST_DOMAIN (illegal vs “loopback”), and the exact rule for UNI=0 paired links (one frame with a PAIR flag vs two LINK_SET frames).

## Q: 
define the bridge’s behavior when SRC_DOMAIN == DST_DOMAIN (illegal vs “loopback”), and the exact rule for UNI=0 paired links (one frame with a PAIR flag vs two LINK_SET frames).

## A: 
## 1. SRC_DOMAIN == DST_DOMAIN behavior

You need one deterministic policy that avoids silent “no-ops” and also avoids accidental self-infection collapse.

### Policy: **Loopback is allowed but quarantined by default**

Implement three loopback modes, selected implicitly by FLAGS and MODE so there’s no extra UI.

#### Rule A — Illegal only when ambiguous

If `SRC_DOMAIN == DST_DOMAIN` and `MODE == OFF`, it is a no-op (valid, emits nothing beyond HEARTBEAT if enabled).  
If `SRC_DOMAIN == DST_DOMAIN` and `MODE != OFF`, it is **LOOPBACK** (legal), but receivers must treat it specially per Rule B.

#### Rule B — Loopback semantics

When loopback is active, the bridge does **not** “route across domains” (there is no domain boundary). Instead it becomes a **policy injector**: it can gate whether DATA and/or AUDIO are considered eligible for absorption/infection _inside that domain_.

Concretely:

*   `MODE = DATA_ONLY`: bridge emits control frames that instruct receivers in the domain: “infection allowed from bus metadata this window,” but no audio tap changes are implied.
    
*   `MODE = AUDIO_ONLY`: bridge emits control frames: “BUS_AUDIO capture is permitted this window,” but infection vectors must be ignored.
    
*   `MODE = BOTH`: both permissions true, but **SAFE must be forced ON** by the bridge unless LOCK is explicitly asserted. This prevents accidental overwrite loops.
    

#### Rule C — Loopback safety forcing

If `SRC_DOMAIN == DST_DOMAIN` and `MODE == BOTH`:

*   If `FLAGS.LOCK == 1`: honor panel SAFE toggle as-is.
    
*   Else (`LOCK==0`): force `SAFE=1` in emitted frames regardless of panel SAFE.
    

This makes “self-domain BOTH without LOCK” automatically non-destructive.

#### Rule D — Optional strict illegal mode (compile-time)

If you want “SRC==DST is always illegal,” it must be explicit and visible. Make it a firmware compile flag, not runtime guessing:

```plain text
$BRIDGE_STRICT_NO_LOOPBACK=0|1
```

If set to 1, then on `SRC==DST` and `MODE!=OFF`, bridge emits LINK_CLEAR and blinks error LED; no LINK_SET is emitted.

Default should be 0 (loopback allowed, quarantined) because it’s musically useful for timed permission windows.

* * *

## 2. Exact rule for UNI=0 paired links

You asked: “one frame with a PAIR flag vs two LINK_SET frames.” Choose **two frames**. It is simpler, robust to partial receivers, and keeps the 12-byte format unchanged.

### Decision: **UNI=0 means emit two LINK_SET frames**

No new flag, no new packet type, no expanded header.

#### Emission rule

When `UNI==0` (bidirectional requested) and `SRC != DST`:

On LINK_ENABLE rising (or LINK button):

1.  Emit LINK_SET for forward link: `(SRC→DST)`
    
2.  Emit LINK_SET for reverse link: `(DST→SRC)`
    

Both frames share:

*   MODE (as selected)
    
*   TTL_TICKS (as selected)
    
*   FLAGS except UNI bit
    

#### The UNI bit in emitted frames

To avoid confusing receivers that interpret UNI bit literally, do this:

*   In the **forward** emitted frame: set `UNI=1`
    
*   In the **reverse** emitted frame: set `UNI=1`
    

In other words: UNI=0 is a **UI request**, not a field that propagates. On the wire, every link frame is always explicitly unidirectional. Bidirectionality is represented by the presence of two unidirectional link frames.

This eliminates “paired interpretation” ambiguity for modules.

#### Optional: Pair coherence without a PAIR flag

Receivers don’t need to know the two links are “paired.” They simply maintain two active entries in their link table, each with its own TTL.

The bridge keeps them coherent by refreshing both in HEARTBEAT.

* * *

## 3. HEARTBEAT behavior for paired links

When LINK_ENABLE is high and UNI UI toggle is OFF (requesting bidirectional), the bridge must emit HEARTBEAT for both directions.

Exact cadence:

Let `$BRIDGE_CTRL_PERIOD_TICKS=20`.

Every control period, emit:

*   HEARTBEAT (SRC→DST) on even periods
    
*   HEARTBEAT (DST→SRC) on odd periods
    

This ensures:

*   Only one control frame per control slot (if you have a tight bus)
    
*   Both directions are refreshed every 40 ticks (e.g., 25 Hz per direction)
    

Constraint: TTL must be ≥ 2 \* $BRIDGE_CTRL_PERIOD_TICKS (so it can survive one missed refresh). Enforce:

If UNI UI is OFF and `TTL_TICKS < 2*$BRIDGE_CTRL_PERIOD_TICKS`, clamp TTL upward to that minimum.

With period 20, minimum TTL becomes 40 ticks (40ms).

* * *

## 4. LINK_CLEAR behavior for paired links

On LINK_ENABLE falling:

*   Emit LINK_CLEAR (SRC→DST)
    
*   Emit LINK_CLEAR (DST→SRC)
    

Same slot staggering as HEARTBEAT if you must keep one frame per control slot. If not constrained, you can emit both immediately.

* * *

## 5. Receiver-side deterministic interpretation

Receivers do not implement “paired link logic.” They implement only:

*   Parse frames.
    
*   Maintain link table keyed by (src,dst).
    
*   Enforce expiry by TTL.
    
*   Enforce SAFE behavior and MODE permissions.
    

Because bidirectionality becomes “two explicit unidirectional links,” modules never guess.

* * *

## 6. Edge case: UNI=0 with SRC==DST

If `SRC==DST` and UNI UI is OFF, treat as loopback; do not emit two frames (they would be identical). Emit only one link frame (or none if strict-no-loopback).

* * *

If you want the absolute minimum implementation footprint, I can provide the exact C structs and emission pseudocode for: `emit_advertise()`, `emit_link_set()`, `emit_link_clear()`, `emit_heartbeat()` including the “paired link staggering” and loopback SAFE forcing.

## Q: 
provide the exact C structs and emission pseudocode for: emit_advertise(), emit_link_set(), emit_link_clear(), emit_heartbeat() including the “paired link staggering” and loopback SAFE forcing.

## A: 
```c
/*
  BRIDGE__DOMAIN_ROUTER__v1
  Control-frame wire protocol + emission pseudocode (exact structs + deterministic rules)

  Assumptions:
    - BUS_DATA is I2C-like; bridge writes 12-byte frames.
    - $BUS_TICK_HZ = 1000
    - $BRIDGE_CTRL_PERIOD_TICKS = 20   // control slot cadence
    - Frame is 12 bytes: MAGIC(2), VER(1), TYPE(1), SRC(1), DST(1), MODE(1), FLAGS(1), TTL(2), CRC16(2)
    - CRC16 = CRC-16/CCITT-FALSE (poly 0x1021, init 0xFFFF)
*/

#include <stdint.h>
#include <stdbool.h>

/* =========================
   Protocol constants
   ========================= */

#define BRIDGE_MAGIC0 0xB2
#define BRIDGE_MAGIC1 0xD7
#define BRIDGE_VER    0x01

// TYPE
#define BR_TYPE_ADVERTISE  0x01
#define BR_TYPE_LINK_SET   0x02
#define BR_TYPE_LINK_CLEAR 0x03
#define BR_TYPE_HEARTBEAT  0x04

// MODE
#define BR_MODE_OFF       0x00
#define BR_MODE_DATA_ONLY 0x01
#define BR_MODE_AUDIO_ONLY 0x02
#define BR_MODE_BOTH      0x03

// FLAGS bits (only lower 4 used)
#define BR_FLAG_UNI   0x01  // bit0
#define BR_FLAG_LOCK  0x02  // bit1
#define BR_FLAG_SAFE  0x04  // bit2
#define BR_FLAG_QUIET 0x08  // bit3

// Timing
#define BR_CTRL_PERIOD_TICKS 20u

/* =========================
   Packed frame struct
   ========================= */

#pragma pack(push, 1)
typedef struct {
  uint8_t  magic0;     // 0xB2
  uint8_t  magic1;     // 0xD7
  uint8_t  ver;        // 0x01
  uint8_t  type;       // enum BR_TYPE_*
  uint8_t  src_domain; // 0..15
  uint8_t  dst_domain; // 0..15
  uint8_t  mode;       // enum BR_MODE_*
  uint8_t  flags;      // bitfield BR_FLAG_*
  uint16_t ttl_ticks;  // little-endian
  uint16_t crc16;      // little-endian CRC-16/CCITT-FALSE over bytes 0..9
} BridgeCtrlFrameV1;
#pragma pack(pop)

_Static_assert(sizeof(BridgeCtrlFrameV1) == 12, "Bridge control frame must be 12 bytes");

/* =========================
   Panel state (UI == packet)
   ========================= */

typedef struct {
  uint8_t  src_domain;     // 0..15 rotary
  uint8_t  dst_domain;     // 0..15 rotary
  uint8_t  mode;           // 0..3 switch (or quantized CV override if enabled elsewhere)
  uint8_t  flags;          // UNI/LOCK/SAFE/QUIET toggles packed (bits0..3)
  uint16_t ttl_ticks;      // computed quantized mapping (already clamped)
  bool     link_enabled;   // direct from gate level (plus button logic elsewhere)
} BridgePanelState;

/* =========================
   Hardware/transport hooks
   ========================= */

// Write exactly n bytes to BUS_DATA. Return true if ACKed.
bool bus_i2c_write(const uint8_t *bytes, uint32_t n);

// Monotonic tick counter at $BUS_TICK_HZ (1ms ticks if 1000Hz)
uint32_t now_ticks(void);

// Provide a simple CRC-16/CCITT-FALSE implementation.
uint16_t crc16_ccitt_false(const uint8_t *data, uint32_t len);

/* =========================
   Helpers: clamping + policy
   ========================= */

static inline uint16_t clamp_u16(uint16_t v, uint16_t lo, uint16_t hi) {
  if (v < lo) return lo;
  if (v > hi) return hi;
  return v;
}

static inline bool flag_is_set(uint8_t flags, uint8_t mask) {
  return (flags & mask) != 0;
}

static inline uint8_t set_flag(uint8_t flags, uint8_t mask, bool on) {
  return on ? (uint8_t)(flags | mask) : (uint8_t)(flags & ~mask);
}

/*
  Loopback SAFE forcing:
    If SRC==DST and MODE==BOTH:
      - If LOCK==1: honor SAFE toggle as-is.
      - Else: force SAFE=1 in emitted frames.
*/
static inline uint8_t apply_loopback_safe_forcing(uint8_t src, uint8_t dst, uint8_t mode, uint8_t flags) {
  if (src == dst && mode == BR_MODE_BOTH) {
    if (!flag_is_set(flags, BR_FLAG_LOCK)) {
      flags = set_flag(flags, BR_FLAG_SAFE, true);
    }
  }
  return flags;
}

/*
  UNI UI request:
    - On the wire, we always emit UNI=1 for each explicit unidirectional link frame.
    - If UI UNI toggle is OFF (meaning "bidirectional requested"), we emit TWO unidirectional frames.
    - Therefore, emitted frames always have BR_FLAG_UNI set.
*/
static inline uint8_t force_wire_unidirectional(uint8_t flags) {
  return (uint8_t)(flags | BR_FLAG_UNI);
}

/* =========================
   Frame builder
   ========================= */

static BridgeCtrlFrameV1 build_frame(uint8_t type,
                                     uint8_t src,
                                     uint8_t dst,
                                     uint8_t mode,
                                     uint8_t flags,
                                     uint16_t ttl_ticks)
{
  BridgeCtrlFrameV1 f;
  f.magic0 = BRIDGE_MAGIC0;
  f.magic1 = BRIDGE_MAGIC1;
  f.ver    = BRIDGE_VER;
  f.type   = type;
  f.src_domain = (uint8_t)(src & 0x0F);
  f.dst_domain = (uint8_t)(dst & 0x0F);
  f.mode       = (uint8_t)(mode & 0x03);
  f.flags      = (uint8_t)(flags & 0x0F); // only low 4 used
  f.ttl_ticks  = ttl_ticks;
  f.crc16      = 0;

  // CRC over first 10 bytes (0..9), i.e., excluding crc16 field.
  f.crc16 = crc16_ccitt_false((const uint8_t*)&f, 10);
  return f;
}

static bool emit_frame(const BridgeCtrlFrameV1 *f) {
  return bus_i2c_write((const uint8_t*)f, sizeof(*f));
}

/* =========================
   Emission API (requested)
   ========================= */

/*
  ADVERTISE:
    - Announces bridge presence + current policy snapshot.
    - Minimal: just a frame with the current SRC/DST/MODE/FLAGS/TTL (same struct).
    - Receivers can treat it as presence signal; LINK is not implied unless LINK_SET follows.
  Rules:
    - If QUIET=1, ADVERTISE may be suppressed by caller policy (not by this function).
    - Always apply loopback SAFE forcing (for deterministic visibility).
    - On wire, UNI bit is set (even though ADVERTISE isn't a link).
*/
bool emit_advertise(const BridgePanelState *ps) {
  uint8_t src  = ps->src_domain;
  uint8_t dst  = ps->dst_domain;
  uint8_t mode = ps->mode;

  uint8_t flags = ps->flags;
  flags = apply_loopback_safe_forcing(src, dst, mode, flags);
  flags = force_wire_unidirectional(flags);

  // TTL for ADVERTISE is informational; receivers can ignore TTL here.
  uint16_t ttl = clamp_u16(ps->ttl_ticks, 20u, 5000u);

  BridgeCtrlFrameV1 f = build_frame(BR_TYPE_ADVERTISE, src, dst, mode, flags, ttl);
  return emit_frame(&f);
}

/*
  LINK_SET:
    - Activates/refreshes a link.
  Rules:
    - If SRC==DST:
        * legal loopback: emit exactly one LINK_SET (no paired reverse).
        * apply loopback SAFE forcing if MODE==BOTH and LOCK==0.
    - If UI UNI toggle is ON: emit one link (src->dst).
    - If UI UNI toggle is OFF: emit two unidirectional LINK_SET frames (src->dst then dst->src),
      but ONLY if src!=dst.
    - On wire, UNI bit must be set in every emitted frame (explicit unidirectional links).
*/
bool emit_link_set(const BridgePanelState *ps) {
  uint8_t src  = ps->src_domain;
  uint8_t dst  = ps->dst_domain;
  uint8_t mode = ps->mode;

  uint16_t ttl = clamp_u16(ps->ttl_ticks, 20u, 5000u);

  // If bidirectional requested, ensure TTL survives staggered heartbeats.
  bool ui_uni = flag_is_set(ps->flags, BR_FLAG_UNI);
  if (!ui_uni && src != dst) {
    uint16_t min_ttl = (uint16_t)(2u * BR_CTRL_PERIOD_TICKS); // 40 ticks default
    if (ttl < min_ttl) ttl = min_ttl;
  }

  uint8_t flags = ps->flags;
  flags = apply_loopback_safe_forcing(src, dst, mode, flags);
  flags = force_wire_unidirectional(flags);

  // Always emit forward link
  BridgeCtrlFrameV1 fwd = build_frame(BR_TYPE_LINK_SET, src, dst, mode, flags, ttl);
  bool ok = emit_frame(&fwd);

  // If bidirectional requested and not loopback, emit reverse link
  if (!ui_uni && src != dst) {
    BridgeCtrlFrameV1 rev = build_frame(BR_TYPE_LINK_SET, dst, src, mode, flags, ttl);
    ok = ok && emit_frame(&rev);
  }

  return ok;
}

/*
  LINK_CLEAR:
    - Deactivates a link immediately.
  Rules:
    - If UI UNI is ON: clear one direction (src->dst).
    - If UI UNI is OFF and src!=dst: clear both directions.
    - If SRC==DST: clear exactly one (loopback).
    - MODE and TTL are included but receivers should ignore for CLEAR; still computed deterministically.
    - Apply loopback SAFE forcing for visibility consistency.
    - On wire, UNI bit is set (unidirectional clear frames).
*/
bool emit_link_clear(const BridgePanelState *ps) {
  uint8_t src  = ps->src_domain;
  uint8_t dst  = ps->dst_domain;
  uint8_t mode = ps->mode;

  uint8_t flags = ps->flags;
  flags = apply_loopback_safe_forcing(src, dst, mode, flags);
  flags = force_wire_unidirectional(flags);

  // TTL for CLEAR can be 0; spec allows TTL=0 only for CLEAR.
  uint16_t ttl = 0;

  bool ui_uni = flag_is_set(ps->flags, BR_FLAG_UNI);

  BridgeCtrlFrameV1 fwd = build_frame(BR_TYPE_LINK_CLEAR, src, dst, mode, flags, ttl);
  bool ok = emit_frame(&fwd);

  if (!ui_uni && src != dst) {
    BridgeCtrlFrameV1 rev = build_frame(BR_TYPE_LINK_CLEAR, dst, src, mode, flags, ttl);
    ok = ok && emit_frame(&rev);
  }

  return ok;
}

/*
  HEARTBEAT:
    - Refreshes TTL and restates current active link state.
  Rules:
    - Only called while LINK_ENABLE is high.
    - If UI UNI is ON: emit HEARTBEAT for (src->dst) every control period.
    - If UI UNI is OFF and src!=dst: emit ONE heartbeat per control period with staggering:
        even period_count -> (src->dst)
        odd  period_count -> (dst->src)
      where period_count increments each time emit_heartbeat() is called.
    - If SRC==DST: emit only one direction (loopback).
    - Apply loopback SAFE forcing.
    - Force UNI bit on wire.
*/
bool emit_heartbeat(const BridgePanelState *ps, uint32_t period_count) {
  uint8_t src  = ps->src_domain;
  uint8_t dst  = ps->dst_domain;
  uint8_t mode = ps->mode;

  uint16_t ttl = clamp_u16(ps->ttl_ticks, 20u, 5000u);

  bool ui_uni = flag_is_set(ps->flags, BR_FLAG_UNI);

  if (!ui_uni && src != dst) {
    uint16_t min_ttl = (uint16_t)(2u * BR_CTRL_PERIOD_TICKS);
    if (ttl < min_ttl) ttl = min_ttl;
  }

  uint8_t flags = ps->flags;
  flags = apply_loopback_safe_forcing(src, dst, mode, flags);
  flags = force_wire_unidirectional(flags);

  uint8_t hb_src = src;
  uint8_t hb_dst = dst;

  if (!ui_uni && src != dst) {
    // Stagger direction
    if ((period_count & 1u) == 1u) {
      hb_src = dst;
      hb_dst = src;
    }
  }

  BridgeCtrlFrameV1 hb = build_frame(BR_TYPE_HEARTBEAT, hb_src, hb_dst, mode, flags, ttl);
  return emit_frame(&hb);
}

/* =========================
   Suggested scheduler usage
   =========================

  In your main loop / timer ISR:

    static uint32_t last_ctrl_tick = 0;
    static uint32_t period_count = 0;

    void bridge_service(const BridgePanelState *ps) {
      uint32_t t = now_ticks();

      // Example: emit ADVERTISE at boot and then every 1000 ticks if QUIET=0
      // (not shown here: track last_advertise_tick)

      if (!ps->link_enabled) return;

      if ((t - last_ctrl_tick) >= BR_CTRL_PERIOD_TICKS) {
        last_ctrl_tick = t;
        (void)emit_heartbeat(ps, period_count++);
      }
    }

  Rising edge on LINK_ENABLE: call emit_link_set(ps)
  Falling edge on LINK_ENABLE: call emit_link_clear(ps)
*/
```

